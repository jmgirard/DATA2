{
  "hash": "003eebbcb5ac3720b286dbc92616dd22",
  "result": {
    "markdown": "---\nformat: \n  revealjs:\n    css: ../../styles.css\n    slide-number: true\n    show-slide-number: all\n    progress: true\n    history: true\n    hash-type: number\n    theme: default\n    code-block-background: true\n    highlight-style: zenburn\n    code-link: false\n    code-copy: true\n    pagetitle: \"Foundations of Data Science\"\n    author-meta: \"Jeffrey Girard\"\n    date-meta: \"2023-03-22\"\n    semester: \"Spring 2023\"\n    course: \"399/800\"\n    lecture: \"10b\"\n---\n\n\n::: {.my-title}\n# [Foundations of]{.my-subtitle}<br />[Data Science]{.blue}\n\n::: {.my-grey}\n[{{< meta semester >}} | Course {{< meta course >}}]{}<br />\n[Jeffrey M. Girard | Lecture {{< meta lecture >}}]{}\n:::\n\n![](../../img/proud_coder_357EDD.svg){.absolute bottom=0 right=0 width=400}\n:::\n\n## Roadmap: Convenience\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n1. Tidy Selection\n  \n2. Across\n\n3. Scale Scores\n\n4. Activity\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li xtkehzkm trigger=loop delay=5000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n# Tidy Selection\n\n## Tidy Selection {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   `filter()` lets us retain rows using criteria\n    -   A version for columns would be convenient!\n\n::: {.fragment .mt1}\n-   This is essentially what tidy selection does\n    -   We can `select()` columns using criteria\n    -   It's like an extension of the `:` sugar\n:::\n\n::: {.fragment .mt1}\n-   We will use selection helpers and predicates\n    -   `starts_with()`, `contains()`, etc.\n    -   `everything()`, `last_col()`\n    -   `where()` and `is.*()`\n\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li tvyxmjyo trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Tidy Selection Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nlibrary(palmerpenguins)\n\npenguins\n\n# Starts with\n\npenguins |> \n  select(starts_with(\"bill_\"))\n\n# PITFALL\n\npenguins |> \n  starts_with(\"bill_\") # error - don't forget select()\n  \n\n# Ends with\n\npenguins |> \n  select(ends_with(\"_mm\"))\n\n# Contains\n\npenguins |> \n  select(contains(\"_length_\"))\n\n# Where\n\npenguins |> \n  select(where(is.factor))\n\npenguins |> \n  select(where(is.numeric))\n\npenguins |> \n  select(where(is.character))\n\n# PITFALL\n\npenguins |> \n  select(where(is.factor())) # error - don't include () after is.*\n\n# Everything\n\npenguins |> \n  select(everything())\n\n# Last Column\n\npenguins |> \n  select(last_col())\n\npenguins |> \n  select(body_mass_g:last_col())\n\n# Negating Criteria\n\npenguins |> \n  select(!ends_with(\"_mm\"))\n\n# Combining Criteria\n\npenguins |> \n  select(where(is.factor) | starts_with(\"body_\"))\n\npenguins |> \n  select(species, where(is.numeric))\n\npenguins |> \n  select(ends_with(\"_mm\") & !contains(\"_depth_\"))\n```\n:::\n\n\n\n# Across\n\n## Across {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   We can apply functions to many columns at once\n    -   This is done using the `across()` function\n    -   It goes inside `mutate()` and `summarize()`\n\n::: {.fragment .mt1}\n-   `across()` pairs very well with tidy selection\n    -   e.g., do this to variables starting with \"x\"\n    -   e.g., do this to all numeric variables\n:::\n\n::: {.fragment .mt1}\n-   Advanced: \"Anonymous functions\"\n    -   Call current col x, then round x to 2 digits\n    -   e.g., `\\(x) round(x, digits = 2)`\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li krmfspeu trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Across Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nstarwars\n\n# Applying the same mutation to multiple variables is a pain\nstarwars |> \n  mutate(\n    hair_color = factor(hair_color),\n    skin_color = factor(skin_color),\n    eye_color = factor(eye_color),\n  )\n\n# dplyr 1.0.0 added across() to make this easier\n\nstarwars |> \n  mutate(\n    across(\n      .cols = c(hair_color, skin_color, eye_color), \n      .fns = factor\n    )\n  )\n\n# We can also use tidyverse shortcuts like the colon (:)\nstarwars |> \n  mutate(\n    across(\n      .cols = c(hair_color:eye_color), \n      .fns = factor\n    )\n  )\n\n# We can also compress it to take up less space\nstarwars |> \n  mutate(across(c(hair_color:eye_color), factor))\n\n# We can also use a tidy selection helper when appropriate\nstarwars |> \n  mutate(\n    across(\n      .cols = ends_with(\"color\"), \n      .fns = factor\n    )\n  )\n\nstarwars |>  \n  mutate(across(.cols = where(is.character), .fns = factor))\n\n# For more control, we use an anonymous function\n\nstarwars |> \n  mutate(\n    height = height * 1000,\n    mass = mass * 1000\n  )\n\nstarwars |> \n  mutate(\n    across(\n      .cols = c(height, mass), \n      .fns = \\(x) x * 1000\n    )\n  )\n\n# Across with summarize\n\nstarwars |> \n  summarize(\n    height = mean(height, na.rm = TRUE),\n    mass = mean(mass, na.rm = TRUE),\n    birth_year = mean(birth_year, na.rm = TRUE)\n  )\n\nstarwars |> \n  summarize(\n    across(\n      .cols = c(height, mass, birth_year), \n      .fns = \\(x) mean(x, na.rm = TRUE)\n    )\n  )\n```\n:::\n\n\n\n# Scale Scores\n\n## Scale Scores {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   In social science, we often use [scale scores]{.b .blue}\n    -   Multiple similar items are combined\n    -   Sums and means are both common\n\n::: {.fragment .mt1}\n-   Calculating scale scores from items is tricky\n    -   When each item is a column...\n    -   ...we calculate scale scores **per row**\n:::\n\n::: {.fragment .mt1}\n-   We can either group per row (using `.by`)\n    -   Or use special row-based functions\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li bdfzpkxv trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Scale Scores Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Simulate a longitudinal dataset with a five-item scale\ndf <- \n  tibble(\n    subject = rep(101:103, each = 3),\n    visit = rep(1:3, times = 3),\n    q1 = sample(x = 0:4, size = 9, replace = TRUE),\n    q2 = sample(x = 0:4, size = 9, replace = TRUE),\n    q3 = sample(x = 0:4, size = 9, replace = TRUE),\n    q4 = sample(x = 0:4, size = 9, replace = TRUE),\n    q5 = sample(x = 0:4, size = 9, replace = TRUE),\n  ) |> \n  print()\n\n# USECASE: Calculate subjects' scores per visit\n\n# Solution 1 (calculate sums and means \"by-hand\")\ndf |> \n  mutate(\n    total_q = q1 + q2 + q3 + q4 + q5,\n    mean_q = (q1 + q2 + q3 + q4 + q5) / 5\n  )\n\n# PITFALL: Attempt to use functions for convenience\ndf |> \n  mutate(\n    total_q = sum(c(q1, q2, q3, q4, q5)),\n    mean_q = mean(c(q1, q2, q3, q4, q5))\n  )\n# But the answers aren't what we wanted! These are ungrouped mutates!\n\n# Solution 2 (turn them into grouped mutates)\ndf |> \n  mutate(\n    total_q = sum(c(q1, q2, q3, q4, q5)),\n    mean_q = mean(c(q1, q2, q3, q4, q5)),\n    .by = c(subject, visit)\n  )\n# These are the answers we wanted\n\n# USECASE: Can we use tidy selection here?\n\n# The : operator does work if they are in order!\ndf |> \n  mutate(\n    total_q = sum(q1:q5),\n    mean_q = mean(q1:q5),\n    .by = c(subject, visit)\n  )\n\n# But starts_with() doesn't...\ndf |> \n  mutate(\n    total_q = sum(starts_with(\"q\")),\n    mean_q = mean(starts_with(\"q\")),\n    .by = c(subject, visit)\n  )\n# Error...\n\n# Solution 3 (use row functions and pick, no .by necessary)\ndf |> \n  mutate(\n    total_q = rowSums(pick(starts_with(\"q\"))),\n    mean_q = rowMeans(pick(starts_with(\"q\")))\n  )\n\n# PITFALL (don't include your sum in your mean)\ndf |> \n  mutate(\n    q_total = rowSums(pick(starts_with(\"q\"))),\n    q_mean = rowMeans(pick(starts_with(\"q\")))\n  )\n# Note that the means are now much higher because they include q_total\n# This is because q_total also starts with q and comes first in mutate()\n```\n:::\n",
    "supporting": [
      "10b_Slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
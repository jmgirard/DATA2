{
  "hash": "6396cf06ecaf74a9eeb15890f638ecaa",
  "result": {
    "markdown": "---\nformat: \n  revealjs:\n    css: ../../styles.css\n    slide-number: true\n    show-slide-number: all\n    progress: true\n    history: true\n    hash-type: number\n    theme: default\n    code-block-background: true\n    highlight-style: zenburn\n    code-link: false\n    code-copy: true\n    pagetitle: \"Foundations of Data Science\"\n    author-meta: \"Jeffrey Girard\"\n    date-meta: \"2023-03-27\"\n    semester: \"Spring 2023\"\n    course: \"399/800\"\n    lecture: \"11a\"\n---\n\n\n::: {.my-title}\n# [Foundations of]{.my-subtitle}<br />[Data Science]{.blue}\n\n::: {.my-grey}\n[{{< meta semester >}} | Course {{< meta course >}}]{}<br />\n[Jeffrey M. Girard | Lecture {{< meta lecture >}}]{}\n:::\n\n![](../../img/proud_coder_357EDD.svg){.absolute bottom=0 right=0 width=400}\n:::\n\n## Roadmap: Reshaping Data\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n1. Separate and Unite\n  \n2. Pivot Longer\n\n3. Pivot Wider\n\n4. Activity\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li xtkehzkm trigger=loop delay=5000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n# Separate and Unite\n\n## Separate and Unite {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n- Remember, we want to store one value per cell\n\n- So we need to split up cells that violate this\n\n- We do this using the `separate_*()` functions\n\n- We can separate using delimiters or by position\n\n:::{.fragment .mt1}\n- We may sometimes want to do the opposite\n\n- To merge many variables into one, we can use...\n\n- The `unite()` function or `str_glue()`\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li gdjyhaga trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Separate and Unite Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nlibrary(tidyverse)\n\n# Create some example data\ndat <- \n  tibble(\n    id = c(\"Ax001x01\", \"Ax002x01\", \"Bx001x01\", \"Bx002x01\", \"Cx001x01\", \"Cx002x01\"),\n    duration = c(\"01:16\", \"01:21\", \"01:49\", \"00:34\", \"00:32\", \"00:54\"),\n    growth = c(\"1.6in\", \"2.6in\", \"4.1cm\", \"2.3cm\", \"3.1in\", \"2.8in\"),\n    symptoms = c(\"pain\", \"pain,irritability\", NA, NA, \"irritability\", \"irritability,diarrhea,nausea\")\n  ) |> \n  print()\n\n# SEPARATE\n\n# Separate a column into multiple columns\ndat |> \n  separate_wider_delim(\n    cols = duration,\n    delim = \":\",\n    names = c(\"min\", \"sec\")\n  )\n\n# Keep the column being separated using remove = FALSE\ndat |> \n  separate_wider_delim(\n    cols = duration,\n    delim = \":\",\n    names = c(\"min\", \"sec\"),\n    cols_remove = FALSE\n  )\n\n# The created variables will be strings but we can use parse_number()\ndat |> \n  separate_wider_delim(\n    cols = duration,\n    delim = \":\",\n    names = c(\"min\", \"sec\"),\n    cols_remove = FALSE\n  ) |> \n  mutate(across(.cols = c(min, sec), .fns = parse_number))\n\n# This also works with more than two \"into\" columns\ndat |> \n  separate_wider_delim(\n    cols = id,\n    delim = \"x\",\n    names = c(\"group\", \"subject\", \"time\")\n  )\n\n# Separate by position rather than by delimiter\ndat |> \n  separate_wider_position(\n    cols = growth,\n    widths = c(growth_value = 3, growth_units = 2)\n  )\n\n# We can specify what to do with too few (or too many) pieces\ndat |> \n  separate_wider_delim(\n    cols = symptoms,\n    delim = \",\",\n    names = c(\"symptom1\", \"symptom2\", \"symptom3\"),\n    too_few = \"align_start\"\n  )\n\ndat |> \n  separate_wider_delim(\n    cols = symptoms,\n    delim = \",\",\n    names = c(\"symptom1\", \"symptom2\", \"symptom3\"),\n    too_few = \"align_end\"\n  )\n\n# Or, in this case, we can instead separate longer (into rows)\ndat |> \n  separate_longer_delim(\n    cols = symptoms,\n    delim = \",\"\n  )\n\n# UNITE\n\nmpg2 <- \n  mpg |> \n  select(manufacturer, model, year, hwy, cty) |>\n  print()\n\n# Unite multiple columns into one string\nmpg2 |> \n  unite(\n    col = \"full_name\",\n    manufacturer, model, year,\n    sep = \" \"\n  ) \n\nmpg2 |> \n  unite(\n    col = \"fuel_eff\",\n    cty, hwy,\n    sep = \" / \"\n  ) \n\n# Or use mutate() and str_glue() to get a bit more control\n# You can \"glue\" in a string by wrapping its name in {}\nmpg2 |> \n  mutate(\n    full_name = str_glue(\"{manufacturer} {model} ({year})\"),\n    full_name = str_to_title(full_name),\n    fuel_eff = str_glue(\"mpg: {cty} city / {hwy} highway\")\n  )\n```\n:::\n\n\n\n# Pivot Longer\n\n## Pivot Longer {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n- Tidy data can have many different shapes\n  -   [Long data]{.b .blue} is useful for MLM and most plots\n  -   Wide data is useful for SEM and other plots\n  \n::: {.fragment .mt1}\n- The `pivot_*()` functions reshape tibbles\n  -   `pivot_longer()` adds rows from columns\n:::\n::: {.fragment .mt1}\n- For `pivot_longer()`, we need...\n  -   `cols` to collapse\n  -   `names_to` is where cols names go\n  -   `values_to` is where cols values go\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li xacejjis trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Pivot Longer Live Coding\n\n\n::: {.cell renv.ignore='true'}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Create example data in wide format\ngradebook <- \n  tibble(\n    student = 1:10,\n    test1 = round(rnorm(10, 81, 10)),\n    test2 = round(rnorm(10, 75, 8)),\n    test3 = round(rnorm(10, 77, 7)),\n    test4 = round(rnorm(10, 80, 5)),\n    test5 = round(rnorm(10, 79, 9))\n  ) |> \n  print()\n\n# This format usually won't work for multilevel modeling or ggplot2\n# ggplot(gradebook, aes(x = ???, y = ???))\n\n# To fix it, we can reshape it (pivot it) to long format\ngradebook2 <- \n  gradebook |> \n  pivot_longer(\n    cols = c(test1, test2, test3, test4, test5), \n    names_to = \"test\", \n    values_to = \"grade\"\n  ) |> \n  print()\n\n# Now this is much easier to work with\nggplot(gradebook2, aes(x = test, y = grade, group = student)) + \n  geom_line() + \n  geom_point()\n\n# Use selection helpers to select columns\ngradebook |> \n  pivot_longer(\n    cols = starts_with(\"test\"), \n    names_to = \"test\", \n    values_to = \"grade\"\n  ) |> \n  print()\n\n# Automatically remove the name prefix and (optionally) convert to numeric\ngradebook |> \n  pivot_longer(\n    cols = starts_with(\"test\"), \n    names_to = \"test\", \n    values_to = \"grade\",\n    names_prefix = \"test\",\n    names_transform = parse_number\n  ) |> \n  print()\n\n# How to select columns with numerical names: wrap them in `backticks`\ntable4a\n\ntable4a |> \n  pivot_longer(\n    cols = c(1999, 2000),\n    names_to = \"year\",\n    values_to = \"cases\"\n  ) # error\n\ntable4a |> \n  pivot_longer(\n    cols = c(`1999`, `2000`),\n    names_to = \"year\",\n    values_to = \"cases\"\n  )\n```\n:::\n\n\n\n# Pivot Wider\n\n## Pivot Wider {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n- Tidy data can have many different shapes\n  -   Long data is useful for MLM and most plots\n  -   [Wide data]{.b .blue} is useful for SEM and other plots\n  \n::: {.fragment .mt1}\n- The `pivot_*()` functions reshape tibbles\n  -   `pivot_wider()` adds columns from rows\n:::\n::: {.fragment .mt1}\n- For `pivot_wider()`, we need...\n  -   `names_from` is where names come from\n  -   `values_from` is where values come from\n:::\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li xacejjis trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Pivot Wider Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Example data in long format\ndiary_data <- \n  tibble(\n    participant = rep(1:3, each = 10, times = 2),\n    day = rep(1:10, each = 2, times = 3),\n    scale = rep(c(\"mood\", \"sleep\"), times = 10*3),\n    score = round(rnorm(n = 60), digits = 1)\n  ) |>  \n  print()\n\n# This format works well for some purposes\nggplot(diary_data, aes(x = scale, y = score)) + geom_boxplot()\n\n# But not others!\n# ggplot(diary_data, aes(x = mood???, y = sleep???))\n\n# To fix this, we can reshape (pivot) it to wide format\ndiary_data |>\n  pivot_wider(\n    names_from = \"scale\",\n    values_from = \"score\"\n  )\n\n# Now we can plot this relationship as desired\ndiary_data |> \n  pivot_wider(\n    names_from = \"scale\",\n    values_from = \"score\"\n  ) |> \n  ggplot(aes(x = mood, y = sleep)) + geom_point()\n\n# We can also add a prefix to each name\ndiary_data\n\ndiary_data |> \n  pivot_wider(\n    names_from = \"day\",\n    values_from = \"score\"\n  )\n\ndiary_data |> \n  pivot_wider(\n    names_from = \"day\",\n    values_from = \"score\",\n    names_prefix = \"day_\"\n  )\n\n# We can also pivot on multiple columns\ndiary_data |> \n  pivot_wider(\n    names_from = c(\"day\", \"scale\"),\n    values_from = \"score\"\n  )\n\n# We can change the way the new names are formed (e.g., with prefix and sep)\ndiary_data |> \n  pivot_wider(\n    names_from = c(\"day\", \"scale\"),\n    values_from = \"score\",\n    names_prefix = \"day\",\n    names_sep = \".\"\n  )\n\n# Example data\nrecords <- \n  tibble(\n    fname = rep(c(\"John\", \"Alice\", \"Buster\", \"John\", \"Zenia\"), each = 2),\n    var = rep(c(\"grad_year\", \"cum_gpa\"), times = 5),\n    val = c(1990, 3.01, 1993, 3.32, 1997, 2.09, 1994, 3.28, 1991, 2.64)\n  ) |> \n  print()\n\n# If the pivoting results in rows that aren't unique, it will nest them\nrecords |> \n  pivot_wider(\n    names_from = \"var\",\n    values_from = \"val\"\n  )\n\n# Get around this by making your rows unique!\nrecords |> \n  mutate(linitial = rep(c(\"A\", \"S\", \"K\", \"Z\", \"I\"), each = 2)) |> \n  pivot_wider(\n    names_from = var,\n    values_from = val\n  )\n```\n:::\n",
    "supporting": [
      "11a_Slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
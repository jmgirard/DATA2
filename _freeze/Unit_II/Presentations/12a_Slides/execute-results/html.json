{
  "hash": "45502b8af36c2af42db1b514677e9494",
  "result": {
    "markdown": "---\nformat: \n  revealjs:\n    css: ../../styles.css\n    slide-number: true\n    show-slide-number: all\n    progress: true\n    history: true\n    hash-type: number\n    theme: default\n    code-block-background: true\n    highlight-style: zenburn\n    code-link: false\n    code-copy: true\n    controls: true\n    pagetitle: \"Foundations of Data Science\"\n    author-meta: \"Jeffrey Girard\"\n    date-meta: \"2023-04-03\"\n    semester: \"Spring 2023\"\n    course: \"399/800\"\n    lecture: \"12a\"\n---\n\n\n::: {.my-title}\n# [Foundations of]{.my-subtitle}<br />[Data Science]{.blue}\n\n::: {.my-grey}\n[{{< meta semester >}} | Course {{< meta course >}}]{}<br />\n[Jeffrey M. Girard | Lecture {{< meta lecture >}}]{}\n:::\n\n![](../../img/proud_coder_357EDD.svg){.absolute bottom=0 right=0 width=400}\n:::\n\n## Roadmap\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n1. Faceting\n  \n2. Positions\n\n3. Stat Summary\n\n4. Activity\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li xtkehzkm trigger=loop delay=5000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n# Faceting\n\n## Faceting {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   [Faceting]{.b .blue} creates multiple subplots\n    -   Each shows a subset of the data\n\n::: {.fragment .mt1}\n-   There are two types of faceting\n    -   **Grid** creates a 2D matrix (`row~col`)\n    -   **Wrap** creates a 1D list (`~var`)\n\n![](../../img/facet.png){width=\"70%\"}\n    \n:::\n\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li gpjaxlut trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Faceting Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Filter out a subset of mpg to use in this section (optional)\nmpg2 <- mpg |> \n  filter(\n    cyl != 5,\n    drv %in% c(\"4\", \"f\"), \n    class != \"2seater\"\n  )\n\n# Create a baseline plot without faceting\np <- ggplot(mpg2, aes(x = displ, y = hwy)) + geom_point()\np\n\n# Add facet wrapping by ~class\np + facet_wrap(~class)\n\n# Control the shape of the output\np + facet_wrap(~class, ncol = 2)\np + facet_wrap(~class, nrow = 2)\n\n# Control the direction of the wrapping (i.e., ordering)\np + facet_wrap(~class, ncol = 2, dir = \"v\") #vertical / top-to-bottom\np + facet_wrap(~class, ncol = 2, dir = \"h\") #horizontal / left-to-right\n\n# Add facet grid by . ~ cyl where each column is a cyl value\np + facet_grid(. ~ cyl)\np + facet_grid(. ~ cyl, labeller = label_both)\n\n# Add facet grid by drv ~ . where each row is a drv value\np + facet_grid(drv ~ ., labeller = label_both)\n\n# Add facet grid by drv ~ cyl where each cell is a drv-cyl combination\np + facet_grid(drv ~ cyl, labeller = label_both)\n\n# We can free up the scales to \"zoom\" for each facet\np + facet_grid(drv ~ cyl, labeller = label_both, scales = \"free\")\np + facet_grid(drv ~ cyl, labeller = label_both, scales = \"free_x\")\np + facet_grid(drv ~ cyl, labeller = label_both, scales = \"free_y\")\n\n# Another example\nggplot(mpg2, aes(x = cty, y = hwy)) + \n  geom_point() + \n  geom_abline(slope = 1, intercept = 0)\n\nggplot(mpg2, aes(x = cty, y = hwy)) + \n  geom_point() + \n  geom_abline(slope = 1, intercept = 0) + \n  facet_wrap(~cyl)\n\nggplot(mpg2, aes(x = cty, y = hwy)) + \n  geom_point() + \n  geom_abline(slope = 1, intercept = 0) + \n  facet_wrap(~cyl, scales = \"free\")\n```\n:::\n\n\n\n# Positions\n\n## Positions {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   Geoms can have their positions changed\n    -   This is very useful for bar/col geoms\n    -   We can show absolute and relative counts\n    -   We can compare counts side-by-side\n\n::: {.fragment .mt1}\n-   This can also be useful for text/label geoms\n    -   e.g., we can include the count numbers\n:::\n\n::: {.fragment .mt1}\n-   We'll return to the plotting of discrete data\n    -   Instead of jittering points, we can plot counts\n:::\n\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li dlqsimus trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Positions Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\nlibrary(palmerpenguins)\npenguins\n\nggplot(penguins, aes(x = species)) + \n  geom_bar(color = \"black\")\n\nggplot(penguins, aes(x = species, y = island)) +\n  geom_jitter(width = 0.25, height = 0.25)\n\n# By default, it stacks the bars on top of each other\nggplot(penguins, aes(x = species, fill = island)) + \n  geom_bar(color = \"black\")\n\n# Make each set of bars the same height (turn y into percentage)\nggplot(penguins, aes(x = species, fill = island)) +  \n  geom_bar(color = \"black\", position = \"fill\") +\n  labs(y = \"proportion\")\n\n# Position the bars side-by-side\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(color = \"black\", position = \"dodge\")\n\nggplot(penguins, aes(x = species, fill = island)) +\n  geom_bar(color = \"black\", position = position_dodge(preserve = \"single\"))\n\n# Plotting from summaries\npenguins |> \n  count(species, island)\n\n# Include zero counts\npenguins |> \n  count(species, island, .drop = FALSE)\n\n# Plot the summary with zero counts\npenguins |> \n  count(species, island, .drop = FALSE) |> \n  ggplot(aes(x = species, y = n, fill = island)) +\n  geom_col(color = \"black\", position = \"dodge\")\n\n# Add counts as text geom (dodging didn't work...)\npenguins |> \n  count(species, island, .drop = FALSE) |> \n  ggplot(aes(x = species, y = n, fill = island, label = n)) +\n  geom_col(color = \"black\", position = \"dodge\") +\n  geom_text(position = \"dodge\")\n\n# Fix dodge by specifying same width\npenguins |> \n  count(species, island, .drop = FALSE) |> \n  ggplot(aes(x = species, y = n, fill = island, label = n)) +\n  geom_col(color = \"black\", position = position_dodge(width = 0.9)) +\n  geom_text(position = position_dodge(width = 0.9))\n\n# Adjust the text vertically to appear above each bar\npenguins |> \n  count(species, island, .drop = FALSE) |> \n  ggplot(aes(x = species, y = n, fill = island, label = n)) +\n  geom_col(color = \"black\", position = position_dodge(width = 0.9)) +\n  geom_text(position = position_dodge(width = 0.9), vjust = -0.5)\n```\n:::\n\n\n\n# Stat Summary\n\n## Stat Summary {.smaller}\n\n::: {.columns .pv4}\n\n::: {.column width=\"60%\"}\n-   To plot summaries, we can use two steps\n    -   Step 1: use `summarize()`\n    -   Step 2: plot the results\n    \n::: {.fragment .mt1}\n-   Or we can use a one-step shortcut in \\{ggplot2\\}\n    -   Step 1: use `stat_summary()`\n    -   The `fun` arg calculates y or x\n    -   The `fun.min` arg calculates ymin or xmin\n    -   The `fun.max` arg calculates ymax or xmax\n    -   The `fun.data` arg calculates all three\n\n:::\n\n:::\n\n::: {.column .tc .pv4 width=\"40%\"}\n\n{{< li ogfgksuz trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n\n:::\n\n## Stat Summary Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# Calculate mean price by cut using summarize\ndiamonds |> \n  summarize(\n    mdepth = mean(depth),\n    .by = cut\n  )\n\n# Then plot this summary tibble\ndiamonds |> \n  summarize(\n    mdepth = mean(depth),\n    .by = cut\n  ) |> \n  ggplot(aes(x = cut, y = mdepth)) +\n  geom_point()\n\n# Or calculate and plot it using stat_summary\nggplot(diamonds, aes(x = cut, y = depth)) +\n  stat_summary(\n    fun = mean,\n    geom = \"point\"\n  )\n\n# Calculate error bar positions using summarize\ndiamonds |> \n  summarize(\n    mdepth = mean(depth),\n    ldepth = mean(depth) - sd(depth),\n    udepth = mean(depth) + sd(depth),\n    .by = cut\n  )\n\ndiamonds |> \n  summarize(\n    mdepth = mean(depth),\n    ldepth = mean(depth) - sd(depth),\n    udepth = mean(depth) + sd(depth),\n    .by = cut\n  ) |> \n  ggplot(aes(x = cut, y = mdepth, ymin = ldepth, ymax = udepth)) +\n  geom_point() +\n  geom_errorbar()\n\n# Pointrange is like a combination of the point and errorbar geoms\ndiamonds |> \n  summarize(\n    mdepth = mean(depth),\n    ldepth = mean(depth) - sd(depth),\n    udepth = mean(depth) + sd(depth),\n    .by = cut\n  ) |> \n  ggplot(aes(x = cut, y = mdepth, ymin = ldepth, ymax = udepth)) +\n  geom_pointrange(linewidth = 1)\n\ndiamonds |> \n  ggplot(aes(x = cut, y = depth)) +\n  stat_summary(\n    fun = mean,\n    fun.min = \\(x) mean(x) - sd(x),\n    fun.max = \\(x) mean(x) + sd(x),\n    geom = \"pointrange\",\n    linewidth = 1\n  )\n\n# Shortcut to calculate mean +/- 1 SD\nlibrary(Hmisc)\ndiamonds |> \n  ggplot(aes(x = cut, y = depth)) +\n  stat_summary(\n    fun.data = \\(x) mean_sdl(x, mult = 1),\n    geom = \"pointrange\",\n    linewidth = 1\n  )\n\n# Adjust multiplier to get mean +/- 2 SD\ndiamonds |> \n  ggplot(aes(x = cut, y = depth)) +\n  stat_summary(\n    fun.data = \\(x) mean_sdl(x, mult = 2),\n    geom = \"pointrange\",\n    linewidth = 1\n  )\n\n# Similar function to calculate 95% CI\ndiamonds |> \n  ggplot(aes(x = cut, y = depth)) +\n  stat_summary(\n    fun.data = \\(x) mean_cl_normal(x, conf.int = 0.95),\n    geom = \"pointrange\",\n    linewidth = 1\n  )\n\n# Combine with positions to do cool stuff\npenguins |> \n  filter(sex %in% c(\"female\", \"male\")) |> \n  ggplot(aes(y = species, x = body_mass_g, color = sex)) +\n  stat_summary(\n    fun.data = mean_cl_normal,\n    geom = \"pointrange\",\n    position = position_dodge(width = 0.25),\n    linewidth = 1\n  )\n\n# Create classic candlestick plot with two summaries/geoms\npenguins |> \n  filter(sex %in% c(\"female\", \"male\")) |> \n  ggplot(aes(x = species, y = body_mass_g, fill = sex)) +\n  stat_summary(\n    fun = mean,\n    geom = \"col\",\n    position = position_dodge(width = 0.9)\n  ) + \n  stat_summary(\n    fun.data = mean_cl_normal,\n    geom = \"errorbar\",\n    position = position_dodge(width = 0.9),\n    width = 0.5\n  )\n```\n:::\n",
    "supporting": [
      "12a_Slides_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}